/* tslint:disable */
/* eslint-disable */
/**
 * Route Optimization OptiFlow
 * With the Route Optimization OptiFlow service you can schedule and optimize the routes of your fleet.
 *
 * The version of the OpenAPI document: 1.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import {
    Appointment,
    AppointmentFromJSON,
    AppointmentFromJSONTyped,
    AppointmentToJSON,
} from './Appointment';
import {
    Leg,
    LegFromJSON,
    LegFromJSONTyped,
    LegToJSON,
} from './Leg';

/**
 * A location visit on a route where one or more tasks are scheduled.
 * @export
 * @interface Stop
 */
export interface Stop {
    /**
     * The unique identifier of the location where this stop is taking place.
     * @type {string}
     * @memberof Stop
     */
    locationId?: string;
    /**
     * 
     * @type {Leg}
     * @memberof Stop
     */
    approach?: Leg;
    /**
     * The point in time when the vehicle arrives at the location. Formatted according to [RFC 3339, section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6).
     * @type {Date}
     * @memberof Stop
     */
    arrival?: Date;
    /**
     * A period of time [s] that is required between the arrival at the location and the start of the first appointment. The preparation duration is scheduled before tasks can be executed at the stop.
     * @type {number}
     * @memberof Stop
     */
    preparationDuration?: number;
    /**
     * A list of appointments that describe the tasks that are scheduled for execution at this stop. Consecutive tasks are grouped into an appointment if they have been assigned to the same time slot.
     * @type {Array<Appointment>}
     * @memberof Stop
     */
    appointments?: Array<Appointment>;
    /**
     * The point in time when the vehicle departs at the location. Formatted according to [RFC 3339, section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6).
     * @type {Date}
     * @memberof Stop
     */
    departure?: Date;
}

export function StopFromJSON(json: any): Stop {
    return StopFromJSONTyped(json, false);
}

export function StopFromJSONTyped(json: any, ignoreDiscriminator: boolean): Stop {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'locationId': !exists(json, 'locationId') ? undefined : json['locationId'],
        'approach': !exists(json, 'approach') ? undefined : LegFromJSON(json['approach']),
        'arrival': !exists(json, 'arrival') ? undefined : (new Date(json['arrival'])),
        'preparationDuration': !exists(json, 'preparationDuration') ? undefined : json['preparationDuration'],
        'appointments': !exists(json, 'appointments') ? undefined : ((json['appointments'] as Array<any>).map(AppointmentFromJSON)),
        'departure': !exists(json, 'departure') ? undefined : (new Date(json['departure'])),
    };
}

export function StopToJSON(value?: Stop | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'locationId': value.locationId,
        'approach': LegToJSON(value.approach),
        'arrival': value.arrival === undefined ? undefined : (value.arrival.toISOString()),
        'preparationDuration': value.preparationDuration,
        'appointments': value.appointments === undefined ? undefined : ((value.appointments as Array<any>).map(AppointmentToJSON)),
        'departure': value.departure === undefined ? undefined : (value.departure.toISOString()),
    };
}

