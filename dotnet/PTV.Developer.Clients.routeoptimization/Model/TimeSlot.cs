/*
 * Route Optimization OptiFlow
 *
 * With the Route Optimization OptiFlow service you can schedule and optimize the routes of your fleet.
 *
 * The version of the OpenAPI document: 1.1
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = PTV.Developer.Clients.routeoptimization.Client.OpenAPIDateConverter;

namespace PTV.Developer.Clients.routeoptimization.Model
{
    /// <summary>
    /// Describes a possibility to schedule an appointment to execute tasks at a location. 
    /// </summary>
    [DataContract(Name = "TimeSlot")]
    public partial class TimeSlot : IEquatable<TimeSlot>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TimeSlot" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected TimeSlot() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="TimeSlot" /> class.
        /// </summary>
        /// <param name="id">A unique identifier of the time slot. Must be unique within each location.  (required).</param>
        /// <param name="earliestStart">The earliest point in time an appointment may start in this time slot. When omitted the appointment may start as early as desired.    When used in conjunction with a latest start time, the earliest start time of a time slot must not be later than its latest start time. When used in conjunction with a latest end time, the earliest start time of a time slot must not be later than its latest end time. Formatted according to [RFC 3339, section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6) and not before &#x60;1970-01-01T00:00:00+00:00&#x60;. The date must provide an offset to UTC. .</param>
        /// <param name="latestStart">The latest point in time an appointment may start in this time slot. When omitted the appointment may start as late as desired.  When used in conjunction with an earliest start time, the latest start time of a time slot must not be earlier than its earliest start time. When used in conjunction with a latest end time, the latest start time of a time slot must not be later than its latest end time. Formatted according to [RFC 3339, section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6) and not before &#x60;1970-01-01T00:00:00+00:00&#x60;. The date must provide an offset to UTC. .</param>
        /// <param name="latestEnd">The latest point in time an appointment may end in this time slot. When omitted the appointment may end as late as desired.  When used in conjunction with an earliest start time, the latest end time of a time slot must not be earlier than its earliest start time. When used in conjunction with an latest start time, the latest end time of a time slot must not be earlier than its latest start time. Formatted according to [RFC 3339, section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6) and not before &#x60;1970-01-01T00:00:00+00:00&#x60;. The date must provide an offset to UTC. .</param>
        /// <param name="maximumAppointments">Describes how many appointments may be assigned to this time slot. When omitted, an unlimited number of appointments may be assigned to this time slot. .</param>
        /// <param name="preparationDuration">Describes how long [s] it takes before the first task can be executed after starting the appointment. (default to 0).</param>
        public TimeSlot(string id = default(string), DateTimeOffset earliestStart = default(DateTimeOffset), DateTimeOffset latestStart = default(DateTimeOffset), DateTimeOffset latestEnd = default(DateTimeOffset), int maximumAppointments = default(int), int preparationDuration = 0)
        {
            // to ensure "id" is required (not null)
            if (id == null) {
                throw new ArgumentNullException("id is a required property for TimeSlot and cannot be null");
            }
            this.Id = id;
            this.EarliestStart = earliestStart;
            this.LatestStart = latestStart;
            this.LatestEnd = latestEnd;
            this.MaximumAppointments = maximumAppointments;
            this.PreparationDuration = preparationDuration;
        }

        /// <summary>
        /// A unique identifier of the time slot. Must be unique within each location. 
        /// </summary>
        /// <value>A unique identifier of the time slot. Must be unique within each location. </value>
        [DataMember(Name = "id", IsRequired = true, EmitDefaultValue = false)]
        public string Id { get; set; }

        /// <summary>
        /// The earliest point in time an appointment may start in this time slot. When omitted the appointment may start as early as desired.    When used in conjunction with a latest start time, the earliest start time of a time slot must not be later than its latest start time. When used in conjunction with a latest end time, the earliest start time of a time slot must not be later than its latest end time. Formatted according to [RFC 3339, section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6) and not before &#x60;1970-01-01T00:00:00+00:00&#x60;. The date must provide an offset to UTC. 
        /// </summary>
        /// <value>The earliest point in time an appointment may start in this time slot. When omitted the appointment may start as early as desired.    When used in conjunction with a latest start time, the earliest start time of a time slot must not be later than its latest start time. When used in conjunction with a latest end time, the earliest start time of a time slot must not be later than its latest end time. Formatted according to [RFC 3339, section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6) and not before &#x60;1970-01-01T00:00:00+00:00&#x60;. The date must provide an offset to UTC. </value>
        [DataMember(Name = "earliestStart", EmitDefaultValue = false)]
        public DateTimeOffset EarliestStart { get; set; }

        /// <summary>
        /// The latest point in time an appointment may start in this time slot. When omitted the appointment may start as late as desired.  When used in conjunction with an earliest start time, the latest start time of a time slot must not be earlier than its earliest start time. When used in conjunction with a latest end time, the latest start time of a time slot must not be later than its latest end time. Formatted according to [RFC 3339, section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6) and not before &#x60;1970-01-01T00:00:00+00:00&#x60;. The date must provide an offset to UTC. 
        /// </summary>
        /// <value>The latest point in time an appointment may start in this time slot. When omitted the appointment may start as late as desired.  When used in conjunction with an earliest start time, the latest start time of a time slot must not be earlier than its earliest start time. When used in conjunction with a latest end time, the latest start time of a time slot must not be later than its latest end time. Formatted according to [RFC 3339, section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6) and not before &#x60;1970-01-01T00:00:00+00:00&#x60;. The date must provide an offset to UTC. </value>
        [DataMember(Name = "latestStart", EmitDefaultValue = false)]
        public DateTimeOffset LatestStart { get; set; }

        /// <summary>
        /// The latest point in time an appointment may end in this time slot. When omitted the appointment may end as late as desired.  When used in conjunction with an earliest start time, the latest end time of a time slot must not be earlier than its earliest start time. When used in conjunction with an latest start time, the latest end time of a time slot must not be earlier than its latest start time. Formatted according to [RFC 3339, section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6) and not before &#x60;1970-01-01T00:00:00+00:00&#x60;. The date must provide an offset to UTC. 
        /// </summary>
        /// <value>The latest point in time an appointment may end in this time slot. When omitted the appointment may end as late as desired.  When used in conjunction with an earliest start time, the latest end time of a time slot must not be earlier than its earliest start time. When used in conjunction with an latest start time, the latest end time of a time slot must not be earlier than its latest start time. Formatted according to [RFC 3339, section 5.6](https://tools.ietf.org/html/rfc3339#section-5.6) and not before &#x60;1970-01-01T00:00:00+00:00&#x60;. The date must provide an offset to UTC. </value>
        [DataMember(Name = "latestEnd", EmitDefaultValue = false)]
        public DateTimeOffset LatestEnd { get; set; }

        /// <summary>
        /// Describes how many appointments may be assigned to this time slot. When omitted, an unlimited number of appointments may be assigned to this time slot. 
        /// </summary>
        /// <value>Describes how many appointments may be assigned to this time slot. When omitted, an unlimited number of appointments may be assigned to this time slot. </value>
        [DataMember(Name = "maximumAppointments", EmitDefaultValue = false)]
        public int MaximumAppointments { get; set; }

        /// <summary>
        /// Describes how long [s] it takes before the first task can be executed after starting the appointment.
        /// </summary>
        /// <value>Describes how long [s] it takes before the first task can be executed after starting the appointment.</value>
        [DataMember(Name = "preparationDuration", EmitDefaultValue = false)]
        public int PreparationDuration { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class TimeSlot {\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  EarliestStart: ").Append(EarliestStart).Append("\n");
            sb.Append("  LatestStart: ").Append(LatestStart).Append("\n");
            sb.Append("  LatestEnd: ").Append(LatestEnd).Append("\n");
            sb.Append("  MaximumAppointments: ").Append(MaximumAppointments).Append("\n");
            sb.Append("  PreparationDuration: ").Append(PreparationDuration).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as TimeSlot);
        }

        /// <summary>
        /// Returns true if TimeSlot instances are equal
        /// </summary>
        /// <param name="input">Instance of TimeSlot to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(TimeSlot input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Id == input.Id ||
                    (this.Id != null &&
                    this.Id.Equals(input.Id))
                ) && 
                (
                    this.EarliestStart == input.EarliestStart ||
                    (this.EarliestStart != null &&
                    this.EarliestStart.Equals(input.EarliestStart))
                ) && 
                (
                    this.LatestStart == input.LatestStart ||
                    (this.LatestStart != null &&
                    this.LatestStart.Equals(input.LatestStart))
                ) && 
                (
                    this.LatestEnd == input.LatestEnd ||
                    (this.LatestEnd != null &&
                    this.LatestEnd.Equals(input.LatestEnd))
                ) && 
                (
                    this.MaximumAppointments == input.MaximumAppointments ||
                    this.MaximumAppointments.Equals(input.MaximumAppointments)
                ) && 
                (
                    this.PreparationDuration == input.PreparationDuration ||
                    this.PreparationDuration.Equals(input.PreparationDuration)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Id != null)
                {
                    hashCode = (hashCode * 59) + this.Id.GetHashCode();
                }
                if (this.EarliestStart != null)
                {
                    hashCode = (hashCode * 59) + this.EarliestStart.GetHashCode();
                }
                if (this.LatestStart != null)
                {
                    hashCode = (hashCode * 59) + this.LatestStart.GetHashCode();
                }
                if (this.LatestEnd != null)
                {
                    hashCode = (hashCode * 59) + this.LatestEnd.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.MaximumAppointments.GetHashCode();
                hashCode = (hashCode * 59) + this.PreparationDuration.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            // Id (string) maxLength
            if (this.Id != null && this.Id.Length > 36)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Id, length must be less than 36.", new [] { "Id" });
            }

            // Id (string) minLength
            if (this.Id != null && this.Id.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Id, length must be greater than 1.", new [] { "Id" });
            }

            // Id (string) pattern
            Regex regexId = new Regex(@"^[a-zA-Z0-9_-]{1,36}$", RegexOptions.CultureInvariant);
            if (false == regexId.Match(this.Id).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Id, must match a pattern of " + regexId, new [] { "Id" });
            }

            // MaximumAppointments (int) minimum
            if (this.MaximumAppointments < (int)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for MaximumAppointments, must be a value greater than or equal to 1.", new [] { "MaximumAppointments" });
            }

            // PreparationDuration (int) minimum
            if (this.PreparationDuration < (int)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for PreparationDuration, must be a value greater than or equal to 0.", new [] { "PreparationDuration" });
            }

            yield break;
        }
    }

}
